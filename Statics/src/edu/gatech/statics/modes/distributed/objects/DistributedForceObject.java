/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package edu.gatech.statics.modes.distributed.objects;

import com.jme.math.Matrix3f;
import com.jme.math.Vector3f;
import edu.gatech.statics.objects.Force;
import edu.gatech.statics.objects.Point;
import edu.gatech.statics.objects.SimulationObject;
import edu.gatech.statics.objects.bodies.Beam;
import edu.gatech.statics.objects.representations.LabelRepresentation;

/**
 *
 * @author Calvin Ashmore
 */
public class DistributedForceObject extends SimulationObject {

    private Force resultantForce;
    private Point resultantAnchor;
    private DistributedForce dl;

    public DistributedForceObject(DistributedForce dl) {
        setName(dl.getName() + " object");
        this.dl = dl;

        // create the force and anchor
        resultantAnchor = new Point(dl.getName() + " anchor", dl.getResultantPosition());
        resultantForce = new Force(resultantAnchor, dl.getPeak().getVectorValue(), "R");
        resultantForce.setName(dl.getName() + " resultant");

        resultantForce.createDefaultSchematicRepresentation();
        resultantAnchor.createDefaultSchematicRepresentation();
    }

    public DistributedForce getDistributedForce() {
        return dl;
    }

    public Point getResultantAnchor() {
        return resultantAnchor;
    }

    public Force getResultantForce() {
        return resultantForce;
    }

    @Override
    public Vector3f getTranslation() {

        // this will occur during persistence
        if (dl.getStartPoint() == null || dl.getEndPoint() == null) {
            return new Vector3f();
        }

        return dl.getStartPoint().getTranslation().add(dl.getEndPoint().getTranslation()).mult(.5f);
    }

    public Point getEndPoint() {
        return dl.getEndPoint();
    }

    public Point getStartPoint() {
        return dl.getStartPoint();
    }

    public Beam getSurface() {
        return dl.getSurface();
    }

    @Override
    public Matrix3f getRotation() {
        //return surface.getRotation();

        // this will occur during persistence
        if (dl.getStartPoint() == null || dl.getEndPoint() == null) {
            return new Matrix3f();
        }

        Vector3f direction;
        direction = dl.getEndPoint().getTranslation().subtract(dl.getStartPoint().getTranslation());
        direction.normalizeLocal();

        Vector3f unitPeak = dl.getPeak().getVectorValue().toVector3f().normalize();
        unitPeak.negateLocal();
        Vector3f myZ = direction.cross(unitPeak);

        Matrix3f mat = new Matrix3f();
        mat.setColumn(0, direction);
        mat.setColumn(1, unitPeak);
        mat.setColumn(2, myZ);

        return mat;
    }

    @Override
    public Vector3f getDisplayCenter() {
        Vector3f endpoint = dl.getStartPoint().getDisplayCenter();

        // the vectors point into the body as opposed to from the body,
        // so the offset generated by the peak will be negative.
        Vector3f peakValue = dl.getPeak().getVectorValue().toVector3f().negate();

        // **** FIXME THIS USES A FIXED VALUE
        return endpoint.add(peakValue.mult(5));
    }

    @Override
    public String getLabelText() {
        return dl.getPeak().getPrettyName();
    }

    @Override
    public void createDefaultSchematicRepresentation() {
        // only one sample is necessary here.
        createDefaultSchematicRepresentation(1, 10);
    }

    public void createDefaultSchematicRepresentation(float displayScale, int arrows) {
        addRepresentation(new DistributedForceRepresentation(this, 30, displayScale, arrows));

        LabelRepresentation label = new LabelRepresentation(this, "label_force");
        addRepresentation(label);
    }
}
